#include "execution/executors/window_function_executor.h"
#include "execution/plans/window_plan.h"
#include "storage/table/tuple.h"
#include "value_factory.h"
#include "aggregation_executor.h"

namespace bustub {

WindowFunctionExecutor::WindowFunctionExecutor(ExecutorContext *exec_ctx, const WindowFunctionPlanNode *plan,
                                               std::unique_ptr<AbstractExecutor> &&child_executor)
    : AbstractExecutor(exec_ctx), plan_(plan), child_executor_(std::move(child_executor)) {}

void WindowFunctionExecutor::Init() { 
    this->child_executor_->Init();
    const auto &child_schema = this->child_executor_->GetOutputSchema();

    /* Iteration to obtain all tuples */
    while (1) {
        Tuple tuple_;
        RID rid_;
        bool ok = this->child_executor_->Next(&tuple_, &rid_);
        if (!ok) break;
        this->tuples.push_back(tuple_);
    }
    /* END */

    /* Collect column indices */
    std::unordered_set<uint32_t> func_column_idx_set;
    for (auto &[func_column_idx, window_function] : this->plan_->window_functions_) {
        func_column_idx_set.insert(func_column_idx);
    }
    /* END */

    /* Define a compare wrapper, return lambda based on order_bys */
    auto cmp_wrapper = [](
        std::vector<std::pair<OrderByType, AbstractExpressionRef>> order_bys_,
        const Schema &output_schema_
    ) -> std::function<bool(Tuple &, Tuple &)> {
        auto real_cmp = [order_bys_, output_schema_] (const Tuple &a, const Tuple &b) -> bool {   
            for (auto &[order_by_type, expr] : order_bys_) {
                auto a_val = expr->Evaluate(&a, output_schema_);
                auto b_val = expr->Evaluate(&b, output_schema_);

                switch(order_by_type) {
                    case OrderByType::INVALID: // NOLINT
                    case OrderByType::DEFAULT: // NOLINT
                    case OrderByType::DESC:
                        if (a_val.CompareLessThan(b_val) == CmpBool::CmpTrue) return true;
                        if (a_val.CompareGreaterThan(b_val) == CmpBool::CmpTrue) return false;
                        break;
                    case OrderByType::ASC: 
                        if (a_val.CompareLessThan(b_val) == CmpBool::CmpTrue) return false;
                        if (a_val.CompareGreaterThan(b_val) == CmpBool::CmpTrue) return true;
                        break;
                }
            }
            return false;
        };

        return real_cmp;
    };
    /* END */

    // Note: All window function aggregate the columns not generated by aggregation function.
    for (auto &[func_column_idx, window_function] : this->plan_->window_functions_) {
        // Collect partition_by and order_by for this window func
        std::vector<std::pair<OrderByType, AbstractExpressionRef>> total_orders{};
        std::vector<std::pair<OrderByType, AbstractExpressionRef>> partition_orders{};

        for (const auto &partition_by : window_function.partition_by_) {
            total_orders.emplace_back(OrderByType::ASC, partition_by);
            partition_orders.emplace_back(OrderByType::ASC, partition_by);
        }
        for (const auto &order_by : window_function.order_by_) {
            total_orders.push_back(order_by);
        }
        /* END */

        /* Sort the child_tuples based on partition_by and order_by */
        std::sort(
            this->tuples.begin(), 
            this->tuples.end(), 
            cmp_wrapper(total_orders, child_schema)
        );
        /* END */

        /* Do aggregate by window function */
        auto group_bys = window_function.partition_by_;
        auto agg_expr = window_function.function_;

        auto agg_iter = this->tuples.begin();
        /* While loop start */
        while (agg_iter != this->tuples.end()) {
            auto upper_bound_iter = std::upper_bound(
                agg_iter,
                this->tuples.end(), 
                *agg_iter,
                cmp_wrapper(partition_orders, child_schema)
            );
            auto lower_bound_iter = agg_iter;

            /* Check window function type and Make default val */
            AggregationType agg_type;
            Value default_value;
            bool is_simple_aggregate_{true};

            switch (window_function.type_) {
                case WindowFunctionType::CountStarAggregate:
                    agg_type = AggregationType::CountStarAggregate;
                    default_value = ValueFactory::GetIntegerValue(0);
                    break;
                case WindowFunctionType::CountAggregate:
                    agg_type = AggregationType::CountAggregate;
                    default_value = ValueFactory::GetNullValueByType(TypeId::INTEGER);
                    break;
                case WindowFunctionType::SumAggregate:
                    agg_type = AggregationType::SumAggregate;
                    default_value = ValueFactory::GetNullValueByType(TypeId::INTEGER);
                    break;
                case WindowFunctionType::MinAggregate:
                    agg_type = AggregationType::MinAggregate;
                    default_value = ValueFactory::GetNullValueByType(TypeId::INTEGER);
                    break;
                case WindowFunctionType::MaxAggregate:
                    agg_type = AggregationType::MaxAggregate;
                    default_value = ValueFactory::GetNullValueByType(TypeId::INTEGER);
                    break;
                case WindowFunctionType::Rank:
                    is_simple_aggregate_ = false;
                    default_value = ValueFactory::GetNullValueByType(TypeId::INTEGER);
                    break;
            }
            /* END */
        
            /* Case 1: simple aggregation */
            if (is_simple_aggregate_) {
                const auto agg_exprs = std::vector<AbstractExpressionRef>{agg_expr};
                const auto agg_types = std::vector<AggregationType>{agg_type};
                SimpleAggregationHashTable aht{agg_exprs, agg_types};
                aht.Clear();
                
                AggregateKey agg_key = MakeAggregateKey(&(*lower_bound_iter), group_bys);

                /* if order_by is omitted, do a global aggregation */
                if (window_function.order_by_.empty()) {
                    for (auto it = lower_bound_iter; it != upper_bound_iter; ++it) {
                        auto agg_value = MakeAggregateValue(&(*it), agg_expr);
                        aht.InsertCombine(agg_key, agg_value);
                    }
                }
                /* END */

                /* Aggregation loop */
                for (auto it = lower_bound_iter; it != upper_bound_iter; ++it) {
                    auto result_tuple_it = this->result_tuples.begin() + std::distance(
                        this->tuples.begin(), it
                    );
                    if (!window_function.order_by_.empty()) {
                        auto agg_value_inner = MakeAggregateValue(&(*it), agg_expr);
                        aht.InsertCombine(agg_key, agg_value_inner);
                    }

                    /* Start */
                    std::vector<Value> values{};
                    for (uint32_t idx = 0; idx < this->GetOutputSchema().GetColumns().size(); idx++) {
                        /**
                        * If it is this window function column, the value is the aggregation value
                        * If it is not a window function column, the value should be from the child tuple
                        * If it is another window function column, keep it as is
                        * Else, the tuple is still growing, let's populate a default value
                        */
                        if (idx == func_column_idx) {
                            values.push_back(aht.Begin().Val().aggregates_.begin()[0]);

                        } else if (func_column_idx_set.count(idx) == 0) {
                            values.push_back(
                                this->plan_->columns_[idx]->Evaluate(&(*it), child_schema)
                            );

                        } else if (result_tuple_it < this->result_tuples.end()) {
                            values.push_back(
                                result_tuple_it->GetValue(
                                    &this->GetOutputSchema(), 
                                    idx
                                )
                            );

                        } else {
                            values.push_back(default_value);
                        }
                    }
                    /* END */

                    if (result_tuple_it < this->result_tuples.end()) {
                        *result_tuple_it = Tuple{values, &this->GetOutputSchema()};
                    } else {
                        this->result_tuples.emplace_back(
                            Tuple{values, &this->GetOutputSchema()}
                        );
                    }
                }
            } else {
                /* Case 2: NOT simple aggregation */
                int global_rank = 0;
                int local_rank = 0;
                for (auto it = lower_bound_iter; it != upper_bound_iter; ++it) {
                    auto result_tuple_it = this->result_tuples.begin() + std::distance(
                        this->tuples.begin(), it
                    );

                    std::vector<Value> values{};
                    /* Start */
                    for (uint32_t idx = 0; idx < this->GetOutputSchema().GetColumns().size(); idx++) {
                        if (idx == func_column_idx) {
                            ++global_rank;
                            if (local_rank == 0 || !this->Equal(
                                *it, 
                                *(it - 1),
                                window_function.order_by_
                            )) local_rank = global_rank;
                            values.push_back(ValueFactory::GetIntegerValue(local_rank));

                        } else if (func_column_idx_set.count(idx) == 0) {
                            values.push_back(
                                this->plan_->columns_[idx]->Evaluate(&(*it), child_schema)
                            );

                        } else if (result_tuple_it < this->result_tuples.end()) {
                            values.push_back(result_tuple_it->GetValue(
                                &this->GetOutputSchema(), 
                                idx
                            ));

                        } else {
                            values.push_back(default_value);
                        }
                    }
                    /* END */

                    if (result_tuple_it < this->result_tuples.end()) {
                        *result_tuple_it = Tuple{values, &this->GetOutputSchema()};
                    } else {
                        this->result_tuples.emplace_back(
                            Tuple{values, &this->GetOutputSchema()}
                        );
                    }
                }
            }
            agg_iter = upper_bound_iter;
        } /* Aggregation loop for single window func ENDs here */
    } /* Loop iterating over window functions ENDS here */

    this->it_ = this->result_tuples.begin();
}   


auto WindowFunctionExecutor::Next(Tuple *tuple, RID *rid) -> bool { 
    if (it_ == this->result_tuples.end()) return false;

    *tuple = *it_;
    *rid = tuple->GetRid();
    ++it_;

    return true; 
}
}  // namespace bustub
